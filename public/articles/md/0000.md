# 目次

# 1. 概要
　とある論文で紹介されていたアルゴリズムの実装を見ていたら，`vector`の代わりに下のようなポインタを用いた動的配列を使っていることに気づいた．

```cpp
int* myDynamicArray = new int[5]; // int型の要素を5つ持つ動的配列
delete[] myDynamicArray; // メモリ解放
```

こういう配列を使う最大のメリットはおそらく実行速度の速さだと思うのだけど，具体的にどれくらい差が出るのか気になったので自分で実験してみることにする．

この記事で検証用に用いたコードは全て[GitHub](https://github.com/akTARDIGRADE13/CppContainerPerformance "書いたコード")にあげているので，気になった方はそちらも合わせて見てください．気になる点がありましたら，そちらにissueを立てるか[twitter](https://twitter.com/akTARDIGRADE13 "twitter")のほうに連絡していただけると助かります．

## 1.1 検証に使うデータ構造
ChatGPT先生に「C++でランダムアクセスがO(1)のデータ構造を全部教えて」と聞いて返ってきたもの全部．

### 1.1.1 配列
```cpp
int Array[5]; // int型の要素を5つ持つ配列
```
サイズ固定．コンパイル時に静的にメモリを確保する．

### 1.1.2 std::array
```cpp
#include <array>
std::array<int, 5> stdArray; // int型の要素を5つ持つstd::array
```
サイズ固定．コンパイル時に静的にメモリを確保する．

普通の配列を扱いやすくしたデータ構造らしい（あんまり詳しく知らない）．

### 1.1.3 動的配列
```cpp
int* dynamicArrayC03 = new int[5]; // int型の要素を5つ持つ動的配列
delete[] dynamicArrayC03; // メモリ解放
```
サイズ固定．実行時に動的にメモリが確保される．メモリの解放が手動で必要．

### 1.1.4 動的配列2
```cpp
#include <memory>
std::unique_ptr<int[]> dynamicArrayC11 = std::make_unique<int[]>(5); // int型の要素を5つ持つ動的配列（C++11以降）
```
サイズ固定．実行時に動的にメモリが確保される．メモリの解放を自動でやってくれる．

若干のオーバーヘッドがあるかもだけど，生ポインタを触りたくなかったらこっちが良さそう．

### 1.1.5 std::vector
```cpp
#include <vector>
std::vector<int> vectorArray; // int型の要素を持つstd::vector
```
サイズ可変．実行時に動的にメモリが確保される．

実行時まで配列の長さがわからないようなプログラムの場合は，サイズの変更が無くてもとりあえずvectorを使っている．安心安全．

個人的には，これと動的配列2の速度がどれくらい違うのか，どっちの方が速いのかが一番気になる．

## 1.2 検証内容
以下の内容について，それぞれ実行時間についての検証を行う．

1. コンパイル時に配列の長さを決定&ランダムアクセス
2. コンパイル時に配列の長さを決定&範囲for文
3. 実行時に配列の長さを決定&メモリの確保+初期化+ランダムアクセス

<br>

また，コンパイル時に最適化オプション（`-O2`）を付ける場合と付けない場合でも比較してみる．

最適化なしのときのコンパイルオプション
: 
    ```bash
    $ g++ test.cpp
    ```

<br>

最適化ありのときのコンパイルオプション
: 
    ```bash
    $ g++ test.cpp -O2
    ```


1回だけだと実行時間のブレが激しいので，1000回実行してその平均値と中央値で比較を行う．

## 1.3 実行環境

~~何を書くべきなんだろう...~~

wsl上でプログラムを実行したので，とりあえずUbuntuの情報とg++のバージョンを載せます．

```bash
$ cat /etc/lsb-release
DISTRIB_ID=Ubuntu
DISTRIB_RELEASE=20.04
DISTRIB_CODENAME=focal
DISTRIB_DESCRIPTION="Ubuntu 20.04.5 LTS"
$ g++ --version
g++ (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0
Copyright (C) 2019 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
```

# 2. 検証1

コンパイル時に配列の長さを決定&ランダムアクセス

[ソースコード](https://github.com/akTARDIGRADE13/CppContainerPerformance/blob/main/test1.cpp "test1.cpp")

あらかじめアクセスするindexのリストを乱数を用いて生成しておくことで，文字通り「ランダム」にアクセスされるような実装にした．

コンパイラがハチャメチャな最適化をしちゃったらちゃんとした検証ができないから，あえて少し遠回りな実装をしたんだけど，意味があるのかはよくわからない...少なくとも検証に対してマイナスな影響はないと思ってる．

## 2.1 結果（最適化なし）

| データ構造          | 平均時間（マイクロ秒） | 中央値時間（マイクロ秒） |
|--------------------|----------------------:|------------------------:|
| 配列               | 2836                 | 2699                   |
| std::array         | 4698                | 4469                   |
| 動的配列            | 2485                 | 2353                   |
| 動的配列2           | 15315                | 14818                  |
| std::vector        | 3812                 | 3610                   |

最速は動的配列．普通の配列よりも若干速いのはなぜ．誤差...にしては大きい気もする．

動的配列2が断トツで遅い．どこでこんな差が生まれたんだろう．

std::arrayよりもstd::vectorの方が速いのも不思議．

## 2.2 結果（最適化あり）

| データ構造          | 平均時間（マイクロ秒） | 中央値時間（マイクロ秒） |
|--------------------|----------------------:|------------------------:|
| 配列               | 1615                | 1533                  |
| std::array         | 1732               | 1649                  |
| 動的配列            | 1661                 | 1586                  |
| 動的配列2           | 1740                | 1655                  |
| std::vector        | 1711                | 1616                   |

`-O2`をつけると恐ろしく速くなるね．

配列が少し抜けてそうだけど，割とどれも似たり寄ったりな感じ．これならvector使っちゃうなぁ．


# 3. 検証2

コンパイル時に配列の長さを決定&範囲for文

動的配列と動的配列2は範囲for文が使えないから普通にindexを指定してる．

[ソースコード](https://github.com/akTARDIGRADE13/CppContainerPerformance/blob/main/test2.cpp "test2.cpp")

## 3.1 結果（最適化なし）

| データ構造          | 平均時間（マイクロ秒） | 中央値時間（マイクロ秒） |
|--------------------|----------------------:|------------------------:|
| 配列               | 21688                 | 21531                   |
| std::array         | 21665                | 21506                   |
| 動的配列            | 20886                 | 20746                   |
| 動的配列2           | 126053                | 125455                  |
| std::vector        | 49599                 | 49775                   |

動的配列2が断トツで遅くて，std::vectorもそこそこ遅い．

それ以外はどれもあんまり変わんない．

## 3.2 結果（最適化あり）

| データ構造          | 平均時間（マイクロ秒） | 中央値時間（マイクロ秒） |
|--------------------|----------------------:|------------------------:|
| 配列               | 4197                | 4165                  |
| std::array         | 4184               | 4133                 |
| 動的配列            | 4219                 | 4173                  |
| 動的配列2           | 4289                | 4239                  |
| std::vector        | 4170                | 4127                   |

うーん，最適化オプション付けたらvectorで全然いいじゃんって感じ．


# 4. 検証3

実行時に配列の長さを決定&メモリの確保+初期化+ランダムアクセス

std::arrayは使えないんだけど，gccだと↓みたいなコードは許容されるらしい．

```cpp
#include<iostream>
int main(){
    int n;
    std::cin >> n;
    int a[n] = {};
    return 0;
}
```

[ソースコード](https://github.com/akTARDIGRADE13/CppContainerPerformance/blob/main/test3.cpp "test3.cpp")

## 4.1 結果（最適化なし）

| データ構造          | 平均時間（マイクロ秒） | 中央値時間（マイクロ秒） |
|--------------------|----------------------:|------------------------:|
| 配列               | 3562                 | 3265                   |
| 動的配列            | 5326                 | 5080                   |
| 動的配列2           | 18144                | 17065                  |
| std::vector        | 5925                 | 5637                   |

動的配列2が断トツ(ry．普通に配列が速い～．

## 4.2 結果（最適化あり）

| データ構造          | 平均時間（マイクロ秒） | 中央値時間（マイクロ秒） |
|--------------------|----------------------:|------------------------:|
| 配列               | 1929                | 1822                  |
| 動的配列            | 1986                 | 1864                  |
| 動的配列2           | 2311                | 2207                 |
| std::vector        | 1975                | 1877                   |

動的配列2だけ若干遅そう．他は全然変わらない．

# 5. まとめ

結果だけ見ると，`-O2`つけたら何でもよくないか...？という気持ちになる．なんか検証上手くできてなさそう．

原因としてありそうなのは

- 実装ミス
- 配列のサイズやループを回す数が小さい
- 問題が不適当

とかかなぁ．手元のpcで実行時間がブレがちなのもちょっと気になってる．もっといい検証方法ないかな．

あるいは，実行時間じゃなくてメモリの使用量とかに目を向けるとまた違った結論が見えてくるのかも．

<br>
<br>
<br>

最後まで読んでいただいてありがとうございました．

ちなみにこの記事がこのサイトで公開する最初の記事になりました．めっちゃ達成感！がある！

寄り道しないでそろそろちゃんと論文読まなきゃー...．

